---
globs: *.py
description: Security best practices for FastAPI applications
---

# Security Best Practices for FastAPI

## Input Validation and Sanitization

### Pydantic Model Validation
```python
from pydantic import BaseModel, validator, Field
from typing import Optional
import re

class PredictionRequest(BaseModel):
    """Request model with comprehensive validation"""
    
    email_body: str = Field(
        ...,
        min_length=1,
        max_length=10000,
        description="Email body text to analyze"
    )
    
    @validator('email_body')
    def validate_email_body(cls, v):
        """Validate and sanitize email body"""
        if not v or not isinstance(v, str):
            raise ValueError('Email body must be a non-empty string')
        
        # Remove potentially dangerous characters
        v = re.sub(r'[<>"\']', '', v)
        
        # Check for suspicious patterns
        suspicious_patterns = [
            r'<script.*?>',
            r'javascript:',
            r'data:text/html',
            r'vbscript:'
        ]
        
        for pattern in suspicious_patterns:
            if re.search(pattern, v, re.IGNORECASE):
                raise ValueError('Email body contains potentially malicious content')
        
        return v.strip()
    
    class Config:
        schema_extra = {
            "example": {
                "email_body": "We would like to schedule an interview with you"
            }
        }
```

### Rate Limiting
```python
from fastapi import Request, HTTPException
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
import time

# Initialize rate limiter
limiter = Limiter(key_func=get_remote_address)

# Add rate limit exceeded handler
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@router.post("/predict")
@limiter.limit("10/minute")  # 10 requests per minute
async def predict_interview(
    request: Request,
    prediction_request: PredictionRequest,
    prediction_service: PredictionService = Depends(get_prediction_service)
):
    """Rate-limited prediction endpoint"""
    # Your prediction logic here
    pass
```

## Authentication and Authorization

### JWT Token Authentication
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from datetime import datetime, timedelta
from app.core.config import Settings

security = HTTPBearer()

class AuthService:
    """Authentication service"""
    
    def __init__(self, settings: Settings):
        self.secret_key = settings.secret_key
        self.algorithm = "HS256"
        self.access_token_expire_minutes = 30
    
    def create_access_token(self, data: dict) -> str:
        """Create JWT access token"""
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(minutes=self.access_token_expire_minutes)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt
    
    def verify_token(self, token: str) -> dict:
        """Verify JWT token"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except JWTError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    auth_service: AuthService = Depends(get_auth_service)
) -> dict:
    """Get current authenticated user"""
    token = credentials.credentials
    payload = auth_service.verify_token(token)
    return payload
```

### API Key Authentication
```python
from fastapi import Header, HTTPException, status
from typing import Optional

async def verify_api_key(x_api_key: Optional[str] = Header(None)) -> str:
    """Verify API key from header"""
    if not x_api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required"
        )
    
    # Validate API key (implement your validation logic)
    if not is_valid_api_key(x_api_key):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key"
        )
    
    return x_api_key

def is_valid_api_key(api_key: str) -> bool:
    """Validate API key"""
    # Implement your API key validation logic
    # This could check against a database, environment variables, etc.
    valid_keys = ["your-secret-api-key", "another-valid-key"]
    return api_key in valid_keys
```

## CORS and Security Headers

### CORS Configuration
```python
from fastapi.middleware.cors import CORSMiddleware

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://yourdomain.com"],  # Specify allowed origins
    allow_credentials=True,
    allow_methods=["GET", "POST"],  # Specify allowed methods
    allow_headers=["*"],  # Be more specific in production
)
```

### Security Headers Middleware
```python
from fastapi import FastAPI, Request, Response
from fastapi.middleware.base import BaseHTTPMiddleware

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """Add security headers to all responses"""
    
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)
        
        # Add security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
        response.headers["Content-Security-Policy"] = "default-src 'self'"
        
        return response

# Add security middleware
app.add_middleware(SecurityHeadersMiddleware)
```

## Data Protection

### Sensitive Data Handling
```python
import logging
from typing import Dict, Any

class SecureLogger:
    """Logger that redacts sensitive information"""
    
    SENSITIVE_PATTERNS = [
        r'password["\']?\s*[:=]\s*["\']?([^"\'\s]+)',
        r'api_key["\']?\s*[:=]\s*["\']?([^"\'\s]+)',
        r'token["\']?\s*[:=]\s*["\']?([^"\'\s]+)',
        r'secret["\']?\s*[:=]\s*["\']?([^"\'\s]+)',
    ]
    
    @classmethod
    def redact_sensitive_data(cls, message: str) -> str:
        """Redact sensitive data from log messages"""
        for pattern in cls.SENSITIVE_PATTERNS:
            message = re.sub(pattern, r'\1=***REDACTED***', message, flags=re.IGNORECASE)
        return message
    
    @classmethod
    def secure_log(cls, level: str, message: str, **kwargs):
        """Log message with sensitive data redacted"""
        redacted_message = cls.redact_sensitive_data(message)
        logger = logging.getLogger(__name__)
        getattr(logger, level)(redacted_message, **kwargs)

# Usage
SecureLogger.secure_log("info", "User login with password=secret123")
# Output: "User login with password=***REDACTED***"
```

### Environment Variables Security
```python
from pydantic import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    """Secure configuration management"""
    
    # API settings
    api_title: str = "Email Interview Classifier"
    api_version: str = "1.0.0"
    
    # Security settings
    secret_key: str = Field(..., min_length=32)
    algorithm: str = "HS256"
    access_token_expire_minutes: int = 30
    
    # Database settings (if applicable)
    database_url: Optional[str] = None
    
    # Model settings
    model_path: str = "models"
    
    class Config:
        env_file = ".env"
        case_sensitive = False
        # Don't include sensitive fields in logs
        fields = {
            "secret_key": {"exclude": True},
            "database_url": {"exclude": True}
        }
```

## Input Sanitization

### Text Sanitization
```python
import html
import re
from typing import str

class TextSanitizer:
    """Text sanitization utilities"""
    
    @staticmethod
    def sanitize_input(text: str) -> str:
        """Sanitize user input text"""
        if not text:
            return ""
        
        # HTML escape
        text = html.escape(text)
        
        # Remove null bytes
        text = text.replace('\x00', '')
        
        # Remove control characters except newlines and tabs
        text = re.sub(r'[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]', '', text)
        
        # Limit length
        text = text[:10000]
        
        return text.strip()
    
    @staticmethod
    def validate_email_content(text: str) -> bool:
        """Validate email content for suspicious patterns"""
        suspicious_patterns = [
            r'<script.*?>.*?</script>',
            r'javascript:',
            r'data:text/html',
            r'vbscript:',
            r'on\w+\s*=',
            r'<iframe.*?>',
            r'<object.*?>',
            r'<embed.*?>'
        ]
        
        for pattern in suspicious_patterns:
            if re.search(pattern, text, re.IGNORECASE | re.DOTALL):
                return False
        
        return True
```

## Error Information Disclosure

### Secure Error Responses
```python
from fastapi import HTTPException
import logging

logger = logging.getLogger(__name__)

class SecureHTTPException(HTTPException):
    """HTTP Exception that doesn't leak sensitive information"""
    
    def __init__(self, status_code: int, detail: str = None, log_error: str = None):
        # Log the actual error internally
        if log_error:
            logger.error(f"Internal error: {log_error}")
        
        # Return generic error to client
        super().__init__(
            status_code=status_code,
            detail=detail or "An error occurred. Please try again later."
        )

# Usage
try:
    # Some operation that might fail
    result = await risky_operation()
except Exception as e:
    raise SecureHTTPException(
        status_code=500,
        detail="Internal server error",
        log_error=f"Database connection failed: {e}"
    )
```

## Request Size Limits

### File Upload Limits
```python
from fastapi import File, UploadFile, HTTPException
from fastapi.middleware.base import BaseHTTPMiddleware

class RequestSizeLimitMiddleware(BaseHTTPMiddleware):
    """Limit request size to prevent DoS attacks"""
    
    def __init__(self, app, max_size: int = 10 * 1024 * 1024):  # 10MB default
        super().__init__(app)
        self.max_size = max_size
    
    async def dispatch(self, request: Request, call_next):
        content_length = request.headers.get("content-length")
        if content_length and int(content_length) > self.max_size:
            raise HTTPException(
                status_code=413,
                detail=f"Request too large. Maximum size is {self.max_size} bytes"
            )
        
        response = await call_next(request)
        return response

# Add middleware
app.add_middleware(RequestSizeLimitMiddleware, max_size=5 * 1024 * 1024)  # 5MB
```

## Configuration Security

### Secure Configuration Loading
```python
import os
from pathlib import Path
from pydantic import BaseSettings, Field

class SecureSettings(BaseSettings):
    """Secure configuration with validation"""
    
    # Required security settings
    secret_key: str = Field(..., min_length=32)
    
    # Optional settings with defaults
    debug: bool = False
    log_level: str = "INFO"
    
    # File paths
    model_path: str = "models"
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"
        case_sensitive = False
        
        # Validate file permissions
        @classmethod
        def validate_file_permissions(cls, v):
            if isinstance(v, str) and Path(v).exists():
                if os.access(v, os.R_OK):
                    return v
                else:
                    raise ValueError(f"File {v} is not readable")
            return v

# Validate configuration on startup
def validate_security_config():
    """Validate security configuration"""
    settings = SecureSettings()
    
    # Check if secret key is not default
    if settings.secret_key == "your-secret-key-here":
        raise ValueError("Please set a secure SECRET_KEY in environment variables")
    
    # Check model path permissions
    model_path = Path(settings.model_path)
    if not model_path.exists():
        raise ValueError(f"Model path {settings.model_path} does not exist")
    
    return settings
```
